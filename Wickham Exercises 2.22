---
title: "Wickham Exercises"
author: "Elizabeth Brannon, Kesicia Dickinson, and Shane Wery"
date: "2/21/2018"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

##Functions

#1. What function allows you to tell if an object is a function? What function allows you to tell if a function is a primitive function?

We could use str() or is.function to tell us if its a function. Similarly, we can use is.primitive to tell if it is a primitive function. 

#2. This code makes a list of all functions in the base package. Use it to answer the following questions:

```{r exercise 1.2}
objs <- mget(ls("package:base"), inherits = TRUE)
funs <- Filter(is.function, objs)
```

#a Which base function has the most arguments?
```{r exercise 1.2.a}

objslength <- c()


for (i in 1:length(funs)){
 funcname <- names(funs)[i]
 funclength <- length(formals(funcname)) 
 objslength[i] <-length
 names(objslength)[i]<- funcname
}

length(objslength)
```


#b How many base functions have no arguments? What’s special about those functions?

#c How could you adapt the code to find all primitive functions?

#3. What are the three important components of a function?

The three important components are the body(), formals(), and environment(). 

#4. When does printing a function not show what environment it was created in?

Printing a function does not show what environment it is a primitive function. It will return null. 

##Lexical Scoping

#1. What does the following code return? Why? What does each of the three c’s mean?
```{r exercise 2.1}
c <- 10
c(c = c)
```
The first c is being assigned to 10. In the second line, the first c is concatnating the values, then the inside is assigning value to the vector, recreating the value of the new c as the value of the first original c in line one as 10. 

#2. What are the four principles that govern how R looks for values?
The four principles are name masking, functions vs. variables, a fresh start, and dynamic lookup. 

#.3 What does the following function return? Make a prediction before running the code yourself.
The function will run through each line in order, first doing 10^2, then adding 1 to that value (100+1), then multiplying 101 by 2, getting 202. 
```{r exercise 2.3}
f <- function(x) {
  f <- function(x) {
    f <- function(x) {
      x ^ 2
    }
    f(x) + 1
  }
  f(x) * 2
}
f(10)
```


##Function Arguments

#1. Clarify the following list of odd function calls:

```{r exercise 3.1}
x <- sample(replace = TRUE, 20, x = c(1:10, NA))
y <- runif(min = 0, max = 1, 20)
cor(m = "k", y = y, u = "p", x = x)
```

#2. What does this function return? Why? Which principle does it illustrate?

```{r exercise 3.2}
f1 <- function(x = {y <- 1; 2}, y = 0) {
  x + y
}
f1()
```

#3. What does this function return? Why? Which principle does it illustrate?

```{r exercise 3.3}
f2 <- function(x = z) {
  z <- 100
  x
}
f2()
```
