---
title: "Wickham Exercises 2.15"
author: "Elizabeth Brannon, Kesicia Dickinson, and Shane Wery"
date: "2/11/2018"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

##Vectors
#1. What are the six types of atomic vector? How does a list differ from an atomic vector?
The six types of atomic vectors are logical, integer, double, character, complex, and raw. Lists are different from atomic vectors because their elements can be of any type, whereas for atomic vectors the type must be the same. For example, if there is a character and some numbers in an atomical vector, the vector will be coerced into a character vector. This does not happen with lists. 

#2. What makes is.vector() and is.numeric() fundamentally different to is.list() and is.character()?
is.vector() and is.numeric() will not test whether the object is a vector or if it is a number. is.vector() will tell you TRUE or FALSE depending on if the object is a vector and has no other characteristics besides their names. Similarly, is.numeric() tells you the "numberliness" according to Wickam, but does not tell you if the vector is a nueric. is.list() and is.character() are different from these two cases because they are actually telling you the type of vector. 


#3. Test your knowledge of vector coercion rules by predicting the output of the following uses of c():

c(1, FALSE): This will give us a numeric vector, because when TRUE or FALSE are combined with an integer, they are coerced into a number. TRUE or FALSE is read as 1 or 0. 
c("a", 1): This will give us a character vector because when a character is read with a number, the number is forced into a character as well. 
c(list(1), "a"): This is combining a list with a character vector and therefore each will be treated as its own list. The first list will remain an integer and the second list will remain a character.
c(TRUE, 1L): This will create an integer vector, both because the presence of an integer will coerce TRUE into an integer and because L creates an integer rather than a double vector. 

```{r exercise 1.3}
#check the predictions. 
c(1, FALSE) 
c("a", 1)
c(list(1), "a")
c(TRUE, 1L)

```

#4. Why do you need to use unlist() to convert a list to an atomic vector? Why doesn’t as.vector() work?

You cannot use as.vector() to convert a list to an atomic vector because lists can contain nested lists, making them, according to Wickham, fundamentally different than vectors. 

#5. Why is 1 == "1" true? Why is -1 < FALSE true? Why is "one" < 2 false?

This is because of the rules of coercion. In the first case, 1=="1", because there is a one character value, both values will be converted to a character value, making it "1" == "1". In the second case, because there is a numeric value, FALSE will be converted into a number, making it -1 > 0. In the last case, "one" < 2, the 2 will be converted into a character value "2". These character values cannot be compared in this way, because they perceived as nominal variables. 

#6. Why is the default missing value, NA, a logical vector? What’s special about logical vectors? (Hint: think about c(FALSE, NA_character_).)

Logical vectors are the most flexible among the vectors when it comes to coecion and this is likely why the default for NA would be a logical vector. Otherwised, when paired with values to be coerced, the NA could force another value to be converted. With NAs being logical values, you can ensure that you do not lose the true attributes of the actual values you have included and instead the NAs will be coerced into that value type. 

##Attributes

#1. An early draft used this code to illustrate structure():

```{r exercise 2.1}
structure(1:5, comment = "my attribute")
?comment
```

But when you print that object you don’t see the comment attribute. Why? Is the attribute missing, or is there something else special about it? (Hint: try using help.)

The comment is not printed in this case becuase comment is a special tag that gives the attribute to the object, but does not print it. 

#2. What happens to a factor when you modify its levels?

```{r exercise 2.2}
f1 <- factor(letters)
f1
levels(f1) <- rev(levels(f1))
f1
```
When you reverse the levels of the object, it also reverses the actual vector. From here, we can assume that if you alter the levels, you are also altering the vector content. 

#3. What does this code do? How do f2 and f3 differ from f1?

```{r exercise 2.3}
f2 <- rev(factor(letters))
f2
f3 <- factor(letters, levels = rev(letters))
f3
```

f2 is only reversing the actual content of the vector, whereas f3 is specifing the content of the vector and then reversing the levels. Both of these are different from what we did in f1 because they are specifically identifying whether it is the factors or the levels that are being reversed. In f1, the command was levels(f1) <- rev(levels(f1)). Since the actual vector f1 is embedded within the reverse command here, it reversed both the factors and the levels. 

##Matrices and Arrays

#1. What does dim() return when applied to a vector?
When applied to a vector, dim() would return null because vectors are not multidimensional. Using the dim() <- however would allow the vector to become or behave as if it is a multidimensional object. 

```{r exercise 3.1}
#example
c <- c(1,2,3,4)
dim(c)

b <- c(4,5,6,7)
dim(b) <- c(2,2) #here, it turns the vector into a matrix. 
b 
```

#2. If is.matrix(x) is TRUE, what will is.array(x) return?
It would return TRUE because a matrix is a type of array.

#3. How would you describe the following three objects? What makes them different to 1:5?
```{r exercise 3.3}
x1 <- array(1:5, c(1, 1, 5))
x1
x2 <- array(1:5, c(1, 5, 1))
x2
x3 <- array(1:5, c(5, 1, 1))
x3
x4 <- c(1:5)
x4
```
x1, x2, and x3 are 3D arrays. In x1, you have 5 1x1 arrays, In x2, you have 1 1x5 array. In x3, you have 1 5x1 array. This is different than just creating an object that is 1:5 because they have three dimensions. You can see the difference in the structure by looking at x4. 

#Data Frames

#1. What attributes does a data frame possess?

A data frame contains similar properties to both matrices and lists. It has names, (colnames() and rownames()) and length (ncol() and nrow()). It also has class. 

#2. What does as.matrix() do when applied to a data frame with columns of different types?

It coercises it into a matrix with the same number of columns and rows as the matrix. 

#3. Can you have a data frame with 0 rows? What about 0 columns?

```{r exercise 4.3}

df <- data.frame(0,0)
str(df)
```
Yes, you can have an empty data frame. 